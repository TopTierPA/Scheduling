<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Top Tier Property Acquisitions - Route Analyzer Pro</title>
  <link rel="icon" type="image/png" href="https://i.ibb.co/9g4w3zT/favicon.png">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <link href='https://fonts.googleapis.com/css?family=Roboto:400,500,700|Oswald:700' rel='stylesheet' type='text/css'>
  <style>
    :root {
      --primary-font: 'Roboto', 'Segoe UI', sans-serif;
      --title-font: 'Oswald', sans-serif;
      --sidebar-bg: #fdfdff;
      --sidebar-width: 24rem;
      --header-height: 55px;
      --accent-color: #0e5ddd;
      --accent-color-focus: #f33c4b;
      --warning-color: #e53e3e;
      --warning-color-hover: #c53030;
      --info-color: #3182ce;
      --info-color-hover: #2b6cb0;
      --available-color: #28a745;
      --available-office-color: #17a2b8;
      --unavailable-color: #dc3545;
      --tight-fit-color: #ffc107;
      --text-color: #03071d;
      --light-text-color: #f8f9fa;
      --medium-gray: #a0aec0;
      --dark-gray: #4a5568;
      --border-color: #e2e8f0;
      --border-radius: 8px;
      --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
      --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
      --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
      --transition-speed: 0.35s;
    }

    *,
    *::before,
    *::after {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    html,
    body {
      width: 100%;
      height: 100%;
      height: 100dvh;
      overflow: hidden;
      font-family: var(--primary-font);
      background-color: #eef2ff;
      font-size: 14px;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    #app-wrapper {
      display: flex;
      flex-direction: column;
      height: 100%;
    }

    .leaflet-touch .leaflet-bar a {
      width: 15px;
      height: 15px;
      line-height: 15px;
    }

    .leaflet-right .leaflet-control {
      margin-right: 3px;
    }

    .leaflet-bottom .leaflet-control {
      margin-bottom: 3px;
    }

    .leaflet-top,
    .leaflet-bottom {
      position: absolute;
      z-index: 400;
      pointer-events: none;
      opacity: 0.4;
    }

    .leaflet-container {
      background: #000000;
      outline-offset: 1px;
    }

    #map-header {
      height: var(--header-height);
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 1rem;
      background-color: #000000;
      background-image: linear-gradient(180deg, #000000 0%, #1e1e20 74%);
      position: relative;
      flex-shrink: 0;
      border: 2px black solid;
      border-left: none;
      border-right: none;
      box-shadow: 0 19px 38px rgba(0, 0, 0, 0.30), 0 15px 12px rgba(0, 0, 0, 0.22);
    }

    .header-left {
      display: flex;
      align-items: center;
      gap: 1rem;
    }

    .header-center {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
    }

    .app-title {
      font-family: var(--title-font);
      font-size: 1.5rem;
      font-weight: 700;
      color: #ffffff;
      text-transform: uppercase;
      letter-spacing: 1.6px;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
      white-space: nowrap;
    }

    #route-date-display {
      color: #fff;
      font-weight: 500;
      font-size: 0.8rem;
      opacity: 0.8;
    }

    #app-container {
      display: flex;
      flex-grow: 1;
      overflow: hidden;
      position: relative;
      border: 2px black solid;
      border-left: 1px black solid;
      box-shadow: 0 3px 6px rgba(0, 0, 0, 0.16), 0 3px 6px rgba(0, 0, 0, 0.23);
    }

    #map-container {
      flex: 1;
      display: flex;
      position: relative;
      background-color: #000000;
      padding: 1px 2px 2px 1px;
      /* padding-left: 2px; */
      /* padding-bottom: 3px; */
      /* padding-top: 1px; */
      /* padding-left: 0; */
      transition: width var(--transition-speed) ease;
      box-shadow: inset 0 0 6px rgb(0 0 0 / 76%);
      /* background: linear-gradient(360deg, #4a73ff, #151d7d); */
    }

    #map {
      position: relative;
      /* outline-style: inset !important; */
      flex: 1;
      background-color: #000;
      z-index: 1;
    }

    #map.dark-map-active .leaflet-tile-pane {
      filter: saturate(135%) brightness(65%) contrast(96%);
    }

    .sidebar,
    #info-panel {
      width: var(--sidebar-width);
      background: var(--sidebar-bg);
      display: flex;
      flex-direction: column;
      z-index: 1002;
      box-shadow: var(--shadow-lg);
      transition: transform var(--transition-speed) ease;
      flex-shrink: 0;
    }

    .sidebar {
      border: 1px black solid;
      box-shadow: 0 19px 38px rgba(0, 0, 0, 0.30), 0 15px 12px rgba(0, 0, 0, 0.22);
    }

    #info-panel {
      position: absolute;
      top: 0;
      left: 0;
      height: 100%;
      background: #ffffffe6;
      transform: translateX(-100%);
      BORDER-TOP-RIGHT-RADIUS: 10PX;
    }

    #info-panel.is-visible {
      transform: translateX(0);
    }

    body.info-panel-active #map-container {
      width: calc(100% - var(--sidebar-width));
    }

    body.info-panel-active .sidebar {
      transform: translateX(-100%);
    }

    .legend-header {
      padding: 0.9rem 1rem;
      text-align: left;
      font-family: 'Roboto';
      background: #f1f5f9;
      font-weight: 700;
      font-size: 0.9rem;
      text-transform: uppercase;
      letter-spacing: 0.6px;
      color: #ffffff;
      border: 1px solid #003a87;
      border-left: none;
      border-right: none;
      padding-left: 16px;
      position: sticky;
      top: 0;
      z-index: 2;
      background: linear-gradient(180deg, #7497ee, #215ff9);
      box-shadow: 0 3px 6px rgba(0, 0, 0, 0.16), 0 1.5px 3px rgba(0, 0, 0, 0.43);
    }

    #legend-items-container {
      flex: 1;
      overflow-y: auto;
      background: #fff;
      padding: 0;
    }

    .legend-item {
      cursor: pointer;
      display: flex;
      flex-direction: column;
      padding: 0.5rem 0rem 0.5rem 0.5rem;
      transition: all 0.2s ease;
      background-color: #fff;
      border-bottom: 1px solid #ddd;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.12), 0 1px 2px rgba(0, 0, 0, 0.24);
    }

    .legend-item:hover {
      background-color: #f7fafc;
    }

    .legend-item.is-hidden {
      opacity: 0.5;
      background-color: #f8f9fa;
    }

    .legend-item-header {
      display: grid;
      grid-template-columns: 1fr auto;
      align-items: center;
      gap: 0.75rem;
    }

    .legend-item-info {
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }

    .legend-item-data {
      display: flex;
      flex-direction: column;
      justify-content: center;
    }

    .name-stops-row {
      display: flex;
      align-items: baseline;
      gap: 0.5rem;
      margin-bottom: 0.25rem;
    }

    .color-box {
      width: 14px;
      height: 14px;
      border-radius: 50%;
      border: 2px solid rgba(0, 0, 0, 0.2);
      flex-shrink: 0;
    }

    .name {
      font-weight: 500;
      font-size: 1.0rem;
      color: var(--text-color);
    }

    .details {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem 1.25rem;
      align-items: center;
      color: var(--dark-gray);
    }

    .detail-point {
      display: flex;
      align-items: center;
      gap: 0.35rem;
      font-size: 0.8rem;
    }

    .stops-count {
      font-size: 0.8rem;
      font-weight: 500;
      background-color: #eef2ff;
      padding: 2px 6px;
      border-radius: 10px;
      color: var(--dark-gray);
    }

    .detail-point .icon {
      font-size: 0.9rem;
    }

    .legend-item-controls {
      display: grid;
      grid-template-columns: repeat(2, 28px);
      grid-template-rows: repeat(2, 28px);
      gap: 2px;
      position: relative;
      padding: 0;
    }

    .control-group-separator {
      position: absolute;
      left: calc(50% - 1px);
      top: 4px;
      width: 2px;
      height: calc(100% - 8px);
      background-color: #e2e8f0;
      border-radius: 1px;
      box-shadow: inset 0 0 2px rgba(0, 0, 0, 0.1);
    }

    .control-btn {
      font-size: 1rem;
      cursor: pointer;
      color: #a0aec0;
      transition: all 0.2s;
      border-radius: 50%;
      width: 28px;
      height: 28px;
      display: grid;
      place-items: center;
      border: none;
      background-color: transparent;
    }

    .control-btn:hover {
      background-color: #edf2f7;
      transform: scale(1.1);
    }

    .control-btn.calendar-btn:hover {
      color: #3182ce;
    }

    .control-btn.gmaps-btn:hover {
      color: #38a169;
    }

    .control-btn.focus-btn:hover {
      color: var(--accent-color-focus);
    }

    .control-btn.visibility-btn:hover {
      color: var(--accent-color);
    }

    .control-btn.focus-btn.is-active {
      color: var(--accent-color-focus);
      background-color: #feebec;
    }

    .control-btn.visibility-btn.is-active {
      color: var(--accent-color);
    }

    .legend-controls {
      padding: 0.8rem;
      background: #fff;
      border-top: 1px solid #eee;
      box-shadow: 0 -5px 15px rgba(0, 0, 0, 0.08);
      padding-bottom: 1rem;
      flex-shrink: 0;
      position: relative;
      z-index: 2;
    }

    .legend-controls .control-group {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 0.8rem;
    }

    .legend-controls .control-group:last-child {
      margin-bottom: 0;
    }

    .legend-controls label {
      font-weight: 500;
    }

    .legend-controls select {
      padding: 5px 8px;
      border-radius: 4px;
      border: 1px solid #ccc;
      flex-grow: 1;
      margin-left: 10px;
    }

    .legend-footer {
      padding: 0;
      background: #fff;
      flex-shrink: 0;
      box-shadow: var(--shadow-lg);
      position: relative;
      z-index: 2;
    }

    #legend-summary th,
    #legend-summary td {
      width: 25%;
      padding: 8px;
      border: 0.5px solid #e6e6e6;
      text-align: CENTER;
    }

    #legend-summary table {
      width: 100%;
      table-layout: fixed;
      font-size: smaller;
      font-weight: 600;
    }

    .toggle-tooltips-btn {
      background: transparent;
      border: 2px solid #104489;
      width: 28px;
      height: 28px;
      border-radius: 50%;
      cursor: pointer;
      font-size: 1rem;
      transition: all 0.2s;
      flex-shrink: 0;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.12), 0 1px 2px rgba(0, 0, 0, 0.24);
    }

    .info-panel-header {
      padding: 0.75rem 1rem;
      display: flex;
      align-items: center;
      gap: 0.75rem;
      flex-shrink: 0;
      BORDER-TOP-RIGHT-RADIUS: 10PX;
    }

    .info-panel-header .name {
      font-size: 1.2rem;
      flex-grow: 1;
      margin: 0;
    }

    #close-info-panel-btn {
      background: #e9ecef;
      border: none;
      width: 32px;
      height: 32px;
      border-radius: 50%;
      cursor: pointer;
      font-size: 1.1rem;
      transition: background-color 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }

    #close-info-panel-btn:hover {
      background: #d1d5db;
    }

    #toggle-tooltips-btn {
      background: transparent;
      border: 1px solid var(--border-color);
      width: 32px;
      height: 32px;
      border-radius: 50%;
      cursor: pointer;
      font-size: 1.1rem;
      transition: all 0.2s;
      flex-shrink: 0;
    }

    #toggle-tooltips-btn:hover {
      background-color: #eef2ff;
    }

    #toggle-tooltips-btn.is-active {
      background-color: #2a6eff;
      color: white;
      /* border-color: #2a3dd1; */
    }

    .info-panel-body {
      flex-grow: 1;
      overflow-y: auto;
      padding: 0;
    }

    .stop-card {
      padding: 0.75rem 1.25rem;
      border-bottom: 1px solid var(--border-color);
    }

    .stop-card:last-child {
      border-bottom: none;
    }

    .stop-header {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      margin-bottom: 0.5rem;
    }

    .stop-number {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      display: grid;
      place-items: center;
      font-weight: bold;
      font-size: 0.8rem;
      flex-shrink: 0;
      color: #fff;
      border: 2px solid;
      background: rgba(20, 20, 20, 0.6);
      backdrop-filter: blur(4px);
      -webkit-backdrop-filter: blur(4px);
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
    }

    .stop-address {
      font-weight: 500;
      font-size: 0.9rem;
      color: var(--text-color);
    }

    .stop-address a,
    .modal-table a {
      color: var(--accent-color);
      text-decoration: none;
      font-weight: 600;
    }

    .stop-address a:hover,
    .modal-table a:hover {
      text-decoration: underline;
    }

    .stop-details-grid {
      padding-left: calc(28px + 0.75rem);
      font-size: 0.8rem;
    }

    .pipedrive-links {
      display: flex;
      gap: 1.5rem;
      margin-bottom: 0.5rem;
    }

    .pipedrive-links .link-item {
      font-size: 0.85rem;
    }

    .pipedrive-links .link-item a {
      color: var(--accent-color);
      text-decoration: none;
      font-weight: 600;
    }

    .pipedrive-links .link-item a:hover {
      text-decoration: underline;
    }

    .stop-attributes {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem 1.5rem;
    }

    .stop-detail-item {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      color: var(--dark-gray);
    }

    .stop-detail-item .icon {
      font-size: 1rem;
      width: 1.2em;
      text-align: center;
    }

    .interior-badge {
      font-weight: bold;
    }

    .interior-badge.true {
      color: #2f855a;
    }

    .interior-badge.false {
      color: #c53030;
    }

    .info-panel-footer {
      padding: 1rem 1.5rem;
      border-top: 1px solid var(--border-color);
      background: #f8f9fa;
    }

    .custom-btn {
      width: 100%;
      padding: 0.4rem;
      font-size: 0.85rem;
      border: none;
      border-radius: var(--border-radius);
      color: white;
      cursor: pointer;
      transition: all 0.3s ease;
      font-weight: 600;
    }

    #fitall {
      width: 70%;
      font-size: 0.85rem;
      border: none;
      border-radius: var(--border-radius);
      color: white;
      cursor: pointer;
      transition: all 0.3s ease;
      margin-left: 15%;
      font-weight: 600;
    }

    .leaflet-interactive {
      stroke-width: 1px;
      stroke-linecap: round;
      stroke-linejoin: round;
    }

    .btn-blue {
      background: linear-gradient(0deg, #1609f0 0%, #316ef4 100%);
    }

    .btn-blue:hover {
      background: linear-gradient(0deg, #060e83 0%, #0c19b4 100%);
    }

    .btn-dark {
      background-color: #6c757d;
    }

    .btn-dark:hover {
      background-color: #475569;
      transform: translateY(-1px);
    }

    .export-buttons {
      display: flex;
      gap: 9px;
      margin-top: 9px;
    }

    #mobile-menu-btn {
      display: none;
      width: 32px;
      height: 32px;
      z-index: 1051;
      cursor: pointer;
      position: absolute;
      right: 1rem;
      top: 50%;
      transform: translateY(-50%);
    }

    .menu-bar {
      width: 24px;
      height: 3px;
      background-color: #ffffff;
      border-radius: 3px;
      position: absolute;
      left: 4px;
      transition: all 0.3s ease;
    }

    .menu-bar.top {
      top: 7px;
    }

    .menu-bar.middle {
      top: 14px;
    }

    .menu-bar.bottom {
      top: 21px;
    }

    #mobile-menu-btn.is-active .menu-bar.top {
      transform: translateY(7px) rotate(45deg);
    }

    #mobile-menu-btn.is-active .menu-bar.middle {
      opacity: 0;
    }

    #mobile-menu-btn.is-active .menu-bar.bottom {
      transform: translateY(-7px) rotate(-45deg);
    }

    .stop-marker {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 20px;
      height: 20px;
      border-radius: 50% 50% 50% 0;
      transform: rotate(-45deg);
      background-color: #333;
      color: white;
      font-weight: bold;
      font-size: 0.7rem;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      border: 2.2px solid #000;
      transition: opacity 0.3s ease;
    }

    .stop-marker span {
      transform: rotate(45deg);
    }

    .home-marker {
      background-color: white !important;
      border-color: white !important;
      color: #333 !important;
      font-size: 1rem !important;
    }

    /* --- STYLES FOR POPUPS (REPLACING TOOLTIPS) --- */
    .tooltip-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 1rem;
      margin-bottom: 4px;
    }

    .copy-tooltip-btn {
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      color: #fff;
      border-radius: 4px;
      cursor: pointer;
      padding: 2px 4px;
      font-size: 0.7rem;
      opacity: 0.7;
      transition: all 0.2s;
    }

    .copy-tooltip-btn:hover {
      opacity: 1;
      background: rgba(255, 255, 255, 0.2);
    }

    hr {
      border: none;
      border-top: 1px solid #566573;
      margin: 4px 0;
    }

    b.title {
      color: #ffffff;
      font-weight: 700;
    }

    /* Base popup style to remove leaflet defaults */
    .leaflet-popup-content-wrapper {
      padding: 0;
    }

    .leaflet-popup-content {
      margin: 0;
    }

    /* Main popup style, mimics .custom-tooltip */
    .custom-popup .leaflet-popup-content-wrapper {
      background: #34495e;
      color: #ecf0f1;
      border-radius: var(--border-radius);
      box-shadow: var(--shadow-lg);
    }

    .custom-popup .leaflet-popup-content {
      padding: 6px 12px;
      font-size: 0.75rem;
      line-height: 1.4;
    }

    .custom-popup .leaflet-popup-tip {
      background: #34495e;
    }

    .custom-popup b {
      font-weight: 600;
      color: #aed5ff;
    }

    .custom-popup .leaflet-popup-close-button {
      color: #ecf0f1 !important;
      padding: 8px 8px 0 0 !important;
    }

    .custom-popup .leaflet-popup-close-button:hover {
      background: none !important;
      color: #ffffff !important;
    }

    /* Leg popup style, mimics .leg-tooltip */
    .leg-popup .leaflet-popup-content-wrapper {
      background-color: rgba(20, 20, 20, 0.9);
      color: #f0f0f0;
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: var(--border-radius);
    }

    .leg-popup .leaflet-popup-content {
      padding: 0;
      font-size: 0.8rem;
    }

    .leg-popup .leaflet-popup-tip {
      background: rgba(20, 20, 20, 0.9);
    }

    .leg-popup .leaflet-popup-close-button {
      display: none;
      /* Hide close button for leg popups as they close on mouseout */
    }

    .leg-tooltip-header,
    .leg-tooltip-body,
    .leg-tooltip-footer {
      padding: 6px 10px;
    }

    .leg-tooltip-header {
      border-bottom: 1px solid rgba(255, 255, 255, 0.2);
    }

    .leg-tooltip-footer {
      border-top: 1px solid rgba(255, 255, 255, 0.2);
      background-color: rgba(0, 0, 0, 0.2);
    }

    .leg-tooltip-header-main {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 1rem;
    }

    .leg-tooltip-header .name {
      font-size: 0.9rem;
      font-weight: bold;
      color: #fff;
      margin: 0;
    }

    .leg-tooltip-header .leg-title {
      font-size: 0.75rem;
      color: var(--medium-gray);
    }

    .leg-tooltip-row {
      display: flex;
      align-items: flex-start;
      margin-bottom: 6px;
    }

    .leg-tooltip-row:last-child {
      margin-bottom: 0;
    }

    .leg-tooltip-icon {
      font-size: 1rem;
      width: 20px;
      text-align: center;
      margin-right: 5px;
      color: #fff;
    }

    .leg-tooltip-content .address {
      font-weight: 500;
    }

    .leg-tooltip-content .time {
      font-size: 0.75rem;
      color: var(--medium-gray);
    }

    .leg-tooltip-footer {
      display: flex;
      justify-content: space-around;
      gap: 10px;
    }

    .leg-tooltip-footer-item {
      font-size: 0.8rem;
      font-weight: bold;
    }

    .static-address-label {
      background: rgba(4, 4, 4, 0.8);
      color: #fff;
      border: 1px solid rgba(255, 255, 255, 0.932);
      box-shadow: none;
      font-size: 0.75rem;
      font-weight: 500;
      padding: 4px 6px;
      border-radius: 4px;
      white-space: nowrap;
      display: flex;
      align-items: center;
    }

    .tooltip-stop-number {
      display: inline-flex;
      justify-content: center;
      align-items: center;
      background-color: var(--accent-color);
      color: white;
      border-radius: 50%;
      width: 1.5em;
      height: 1.5em;
      font-weight: bold;
      font-size: 0.8em;
      margin-right: 6px;
      flex-shrink: 0;
    }

    .exit-focus-btn {
      padding: 5px 16px;
      margin-top: 11px;
      margin-left: 25%;
      margin-bottom: 0;
      text-align: center;
      font-size: 1rem;
      font-weight: bold;
      border-radius: var(--border-radius);
      cursor: pointer;
      left: 80px;
      right: 100px;
      background: var(--accent-color-focus);
      color: #fff;
      border: none;
      box-shadow: var(--shadow-lg);
      transition: all 0.3s ease;
      display: none;
    }

    .exit-focus-btn:hover {
      filter: brightness(1.1);
      transform: translateY(-1px);
    }

    #exit-focus-btn-map {
      position: absolute;
      bottom: 6px;
      right: 1px;
      z-index: 1013;
    }

    body.focus-mode-active #exit-focus-btn-map {
      display: block;
      width: 9rem;
      margin-left: 55.5%;
      opacity: 0.92;
      padding: 3px 0 4px 0px;
    }

    body.info-panel-active #exit-focus-btn-map {
      display: none;
    }

    #special-info-buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-bottom: 0.8rem;
    }

    .special-btn {
      flex: 1;
      padding: 0.5rem;
      font-size: 0.8rem;
      font-weight: 600;
      border: none;
      border-radius: var(--border-radius);
      color: white;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      background-color: var(--accent-color);
      min-width: 150px;
    }

    .special-btn:hover {
      filter: brightness(1.1);
    }

    .special-btn.btn-warning {
      background-color: var(--warning-color);
    }

    .special-btn.btn-warning:hover {
      background-color: var(--warning-color-hover);
    }

    .special-btn.btn-info {
      background-color: #4a5568;
      box-shadow: 0 2px 5px 0 rgba(0, 0, 0, 0.16), 0 2px 10px 0 rgba(0, 0, 0, 0.12);
    }

    .special-btn.btn-info:hover {
      background-color: #2d3748;
      box-shadow: 0 5px 11px 0 rgba(0, 0, 0, 0.18), 0 4px 15px 0 rgba(0, 0, 0, 0.15);
      transform: translateY(-1px);
    }

    .special-btn .badge {
      background-color: rgba(0, 0, 0, 0.2);
      color: white;
      padding: 0.1rem 0.4rem;
      border-radius: 10px;
      font-size: 0.75rem;
      font-weight: bold;
    }

    .stop-subject {
      font-weight: 600;
      color: var(--dark-gray);
      margin: 0.25rem 0 0.5rem;
      font-size: 0.85rem;
      line-height: 1.3;
    }

    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(5px);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 2000;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s ease, visibility 0.3s ease;
    }

    .modal-overlay.is-visible {
      opacity: 1;
      visibility: visible;
    }

    .modal-container {
      background: #fff;
      border-radius: var(--border-radius);
      box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
      width: 90%;
      max-width: 950px;
      max-height: 90vh;
      display: flex;
      flex-direction: column;
      transform: scale(0.95);
      transition: transform 0.3s ease;
    }

    .modal-overlay.is-visible .modal-container {
      transform: scale(1);
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1rem 1.5rem;
      border-bottom: 1px solid var(--border-color);
      font-size: 1.2rem;
      font-weight: 600;
    }

    .modal-header.info-header {
      background-color: var(--info-color);
      color: white;
    }

    .modal-header.conflict-header {
      background-color: var(--warning-color);
      color: white;
    }

    .modal-close-btn {
      background: none;
      border: none;
      font-size: 1.5rem;
      cursor: pointer;
      color: var(--dark-gray);
      transition: transform 0.2s;
    }

    .modal-close-btn:hover {
      transform: scale(1.1);
    }

    .modal-header.conflict-header .modal-close-btn,
    .modal-header.info-header .modal-close-btn {
      color: white;
    }

    .modal-body {
      overflow-y: auto;
      padding: 1.5rem;
    }

    .modal-body p {
      margin-bottom: 1rem;
    }

    .modal-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.9rem;
    }

    .modal-table th,
    .modal-table td {
      padding: 0.75rem;
      text-align: left;
      border-bottom: 1px solid var(--border-color);
      vertical-align: middle;
    }

    .modal-table th {
      background-color: #f8f9fa;
      font-weight: 600;
    }

    .modal-table tr:last-child td {
      border-bottom: none;
    }

    .modal-table tr:hover {
      background-color: #f1f5f9;
    }

    #scheduler-modal .modal-body {
      background-color: #f8f9fa;
    }

    #scheduler-form {
      background: #fff;
      padding: 1.5rem;
      border-radius: var(--border-radius);
      box-shadow: var(--shadow-sm);
      margin-bottom: 1.5rem;
      display: grid;
      grid-template-columns: 2fr 1fr 1fr;
      gap: 1rem;
      align-items: flex-end;
    }

    #scheduler-form .form-group {
      display: flex;
      flex-direction: column;
    }

    #scheduler-form label {
      margin-bottom: 0.5rem;
      font-weight: 600;
      font-size: 0.85rem;
      color: var(--dark-gray);
    }

    #scheduler-form input,
    #scheduler-form select {
      padding: 8px;
      border-radius: 4px;
      border: 1px solid #ccc;
    }

    #scheduler-form .address-group {
      grid-column: 1 / 2;
      display: flex;
      align-items: flex-end;
      gap: 0.5rem;
    }

    #scheduler-form .address-group .form-group {
      flex-grow: 1;
    }

    #scheduler-actions {
      grid-column: 1 / -1;
    }

    #scheduler-results-container {
      font-size: 0.9rem;
    }

    .status-badge {
      display: inline-block;
      padding: 0.25em 0.6em;
      font-size: 0.8em;
      font-weight: 700;
      line-height: 1;
      text-align: center;
      white-space: nowrap;
      vertical-align: baseline;
      border-radius: 0.25rem;
      color: #fff;
    }

    .status-badge.available {
      background-color: var(--available-color);
    }

    .status-badge.office-avoid {
      background-color: var(--available-office-color);
    }

    .status-badge.unavailable {
      background-color: var(--unavailable-color);
    }

    .status-badge.tight-fit {
      background-color: var(--tight-fit-color);
      color: #000;
    }

    .if-assigned-details {
      border-top: 1px dashed #ccc;
      margin-top: 8px;
      padding-top: 8px;
    }

    .if-assigned-details .title {
      font-weight: bold;
      font-size: 0.8rem;
      color: #333;
      text-transform: uppercase;
    }

    .if-assigned-details ul {
      list-style-type: none;
      padding-left: 0;
      margin: 5px 0 0 0;
      font-size: 0.8rem;
    }

    .if-assigned-details li {
      margin-bottom: 3px;
    }

    #png-legend-container {
      display: none;
      position: absolute;
      bottom: 20px;
      left: 10px;
      z-index: 1001;
      background: rgba(255, 255, 255, 0.85);
      backdrop-filter: blur(5px);
      padding: 15px;
      border-radius: 8px;
      box-shadow: var(--shadow-md);
      border: 1px solid rgba(0, 0, 0, 0.2);
      font-family: var(--primary-font);
    }

    .png-legend-title {
      font-weight: bold;
      font-size: 1.1rem;
      margin-bottom: 8px;
      padding-bottom: 5px;
      border-bottom: 1px solid #999;
      color: #000;
    }

    .png-legend-title .color-box {
      margin-right: 8px;
    }

    .png-legend-item {
      display: flex;
      align-items: center;
      margin-bottom: 5px;
      font-size: 0.9rem;
      color: #000;
      white-space: nowrap;
    }

    .png-legend-item .color-box {
      width: 14px;
      height: 14px;
      margin-right: 8px;
      border-radius: 50%;
      border: 1px solid #333;
    }

    .png-legend-stop-item {
      font-size: 0.85rem;
      margin-bottom: 4px;
      color: #000;
      white-space: nowrap;
    }

    .png-legend-stop-item .stop-num-icon {
      display: inline-block;
      width: 20px;
      text-align: center;
      font-weight: bold;
      color: var(--accent-color);
      margin-right: 4px;
    }

    @media (max-width: 900px) {
      #map-header {
        justify-content: space-between;
      }

      .main-logo {
        position: static;
        transform: none;
      }

      .header-content {
        display: none;
      }

      #mobile-menu-btn {
        display: block;
        position: static;
        transform: none;
      }

      .sidebar,
      #info-panel {
        position: absolute;
        top: 0;
        left: 0;
        width: min(var(--sidebar-width), 100vw);
        height: 100%;
        transform: translateX(-100%);
      }

      .sidebar.is-open {
        transform: translateX(0);
      }

      body.info-panel-active #map-container {
        width: 100%;
      }

      body.info-panel-active .sidebar {
        transform: translateX(-100%);
      }

      #info-panel.is-visible {
        transform: translateX(0);
      }

      #route-date-display {
        display: none;
      }
    }

    @media (max-width: 600px) {
      .app-title {
        font-size: 1.1rem;
        letter-spacing: 1px;
      }

      .main-logo img {
        height: 26px;
      }
    }

    @media (max-width: 900px) and (orientation: landscape) {
      .sidebar.is-open {
        width: var(--sidebar-width);
        height: 100%;
      }

      #info-panel.is-visible {
        width: var(--sidebar-width);
        height: 100%;
      }
    }
  </style>
</head>

<body>
  
  <div id="app-wrapper">
    <div id="map-header">
      <div class="header-left">
        <span class="main-logo"><img height="30" src="https://toptierpa.com/wp-content/themes/toptier/images/TopTier-WhiteLogo.png" style="padding-top: 5px; vertical-align: middle;"></span>
      </div>
      <div class="header-center">
        <span class="app-title">Inspection Route Comparison Tool</span>
        <span id="route-date-display"></span>
      </div>
      <div id="mobile-menu-btn">
        <div class="menu-bar top"></div>
        <div class="menu-bar middle"></div>
        <div class="menu-bar bottom"></div>
      </div>
    </div>
    <div id="app-container">
      <div class="sidebar" id="legend">
        <div class="legend-header"><span>Inspectors</span></div>
        <div id="legend-items-container"></div>
        <div class="legend-footer">
          <div id="legend-summary"></div>
        </div>
        <div class="legend-controls">
          <div id="special-info-buttons"></div>
          <div class="control-group">
            <label for="map-style-select">Map Style:</label>
            <select id="map-style-select" onchange="changeMapStyle(this.value)">
              <option value="streets">Streets</option>
              <option value="satellite">Satellite</option>
              <option value="dark" selected>Dark</option>
            </select>
          </div>
          <button id="fitall" onclick="fitAllVisibleRoutes()" class="custom-btn btn-blue">Fit All Visible Routes</button>
          <div class="export-buttons">
            <button onclick="exportCSV()" class="custom-btn btn-blue">Export as CSV</button>
            <button onclick="exportPNG()" class="custom-btn btn-blue">Export as PNG</button>
          </div>
<!--    sends the data thru iframe    -->
<button onclick="sendDataToParent()" class="custom-btn btn-dark" style="margin-top: 10px;">Send Data to Main Page</button>
          
        </div>
      </div>

      <div id="info-panel"></div>

      <div id="map-container">
        <div id="map"></div>
        <div id="png-legend-container"></div>
        <button id="exit-focus-btn-map" class="exit-focus-btn">✖ Exit Focus</button>
      </div>
    </div>
  </div>

  <div id="adjustments-modal" class="modal-overlay">
    <div class="modal-container">
      <div class="modal-header">
        <span>Time Adjustments</span>
        <button class="modal-close-btn">×</button>
      </div>
      <div class="modal-body">
        <table class="modal-table" id="adjustments-table">
          <thead>
            <tr>
              <th>Inspector</th>
              <th>Original Time</th>
              <th>New Time</th>
              <th>Reason</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </div>
  </div>

  <div id="unassigned-modal" class="modal-overlay">
    <div class="modal-container">
      <div class="modal-header conflict-header">
        <span>⚠️ Unassigned Inspections</span>
        <button class="modal-close-btn">×</button>
      </div>
      <div class="modal-body">
        <p>The following inspections could not be assigned due to scheduling conflicts or invalid data:</p>
        <table class="modal-table" id="unassigned-table">
          <thead>
            <tr>
              <th>Activity ID</th>
              <th>Address</th>
              <th>Reason</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </div>
  </div>

  <div id="data-issues-modal" class="modal-overlay">
    <div class="modal-container">
      <div class="modal-header info-header">
        <span>ℹ️ Data Issues & Cancellations</span>
        <button class="modal-close-btn">×</button>
      </div>
      <div class="modal-body">
        <p>The following inspections were excluded from routing due to data issues or cancellation:</p>
        <table class="modal-table" id="data-issues-table">
          <thead>
            <tr>
              <th>Activity ID</th>
              <th>Deal ID</th>
              <th>Address</th>
              <th>Reason</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </div>
  </div>

  <div id="scheduler-modal" class="modal-overlay">
    <div class="modal-container">
      <div class="modal-header">
        <span>Availability & Scheduling Assistant</span>
        <button class="modal-close-btn">×</button>
      </div>
      <div class="modal-body">
        <div id="scheduler-form">
          <div class="address-group">
            <div class="form-group">
              <label for="new-inspection-address">New Inspection Address</label>
              <input type="text" id="new-inspection-address" placeholder="e.g., 123 Main St, Orlando, FL">
            </div>
            <button id="geocode-btn" class="custom-btn btn-dark" style="width: auto; padding: 8px 12px; margin-bottom: 0;">Find on Map</button>
          </div>
          <div class="form-group">
            <label for="inspection-time">Inspection Start Time</label>
            <input type="time" id="inspection-time" value="12:00">
          </div>
          <div class="form-group">
            <label for="inspection-duration">Inspection Duration (min)</label>
            <input type="number" id="inspection-duration" value="60" step="15">
          </div>
          <div id="scheduler-actions" class="form-group">
            <button id="check-availability-btn" class="custom-btn btn-blue" style="padding: 10px;">Find Available Inspectors</button>
          </div>
        </div>
        <div id="scheduler-results-container">
          <table class="modal-table" id="scheduler-results-table">
            <thead>
              <tr>
                <th>Feasibility</th>
                <th>Inspector</th>
                <th>Stops Today</th>
                <th>Travel to Site</th>
                <th>Status & Details</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td colspan="5" style="text-align:center; color: var(--dark-gray);">Enter inspection details above to check availability.</td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
    </div>
<!-- new tag for wrapper -->
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/dom-to-image/2.6.0/dom-to-image.min.js"></script>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/dom-to-image/2.6.0/dom-to-image.min.js"></script>
  <script>
    // --- DATA SOURCE (MODIFIED) ---
    // Changed from 'const' to 'let' to allow data to be loaded from postMessage
    let rawData = {};

    // --- GLOBAL VARIABLES & CONSTANTS ---
    const STADIA_API_KEY = '456a0161-7a8c-4acd-8351-153465fd1c4c';
    const OFFICE_COORDS = {
      lat: 28.6338,
      lng: -81.3685
    };
    const AVERAGE_SPEED_MPH = 45;
    const MIN_TRAVEL_BUFFER_MINUTES = 15;
    let map, currentMapLayers = [];
    const personLayersData = {};
    let isInFocusMode = false;
    let tooltipsVisibleInFocus = true;
    let peopleRouteData = [];
    let animationFrameCount = 0;
    let lastOpenPanel = 'legend';
    let focusedPersonId = null;
    let isTabFocusActive = false;
    let tabFocusIndex = -1;
    let masterSegmentList = [];
    let schedulerLayerGroup = L.layerGroup();
    const preAssignedColors = {
      "11900623": "#19ffba",
      "13350780": "#ff3917",
      "19633798": "#197dff",
      "22141669": "#FFFF00",
      "23399288": "#e059ff"
    };
    const backupColors = ['#FF1493', '#00FFFF', '#FF8C00', '#32CD32', '#9370DB', '#20B2AA', '#FF00FF', '#00FF7F', '#00BFFF', '#7FFF00', '#FFD700', '#FF7F50', '#ADFF2F', '#40E0D0', '#DA70D6'];
    let backupColorIndex = 0;
    const routeColors = {};

    // --- DATA PROCESSING & UTILITY FUNCTIONS ---
    function filterAndPrepareSchedules(allSchedules) {
      const cleanSchedules = {};
      const dataIssues = [];
      for (const inspectorId in rawData.inspectors) {
        if (!cleanSchedules[inspectorId]) {
          cleanSchedules[inspectorId] = [];
        }
        const inspections = allSchedules[inspectorId] || [];
        inspections.forEach(inspection => {
          const hasValidCoords = inspection.locationCoords && inspection.locationCoords.lat != null && inspection.locationCoords.lng != null;
          const isRoutable = inspection.timeEST !== 'N/A' && inspection.durationMinutes > 0;
          if (!hasValidCoords) {
            dataIssues.push({
              ...inspection,
              reason: "Invalid or missing coordinates."
            });
          } else if (!isRoutable) {
            dataIssues.push({
              ...inspection,
              reason: "Cancelled or has no time/duration."
            });
          } else {
            cleanSchedules[inspectorId].push(inspection);
          }
        });
      }
      return {
        cleanSchedules,
        dataIssues
      };
    }
    const processData = (appData) => Object.keys(appData.inspectors).map(id => {
      const inspector = appData.inspectors[id];
      let color = preAssignedColors[id] || backupColors[backupColorIndex++ % backupColors.length];
      routeColors[id] = color;
      const schedule = JSON.parse(JSON.stringify(appData.schedules[id] || []));
      schedule.sort((a, b) => a.timeEST.localeCompare(b.timeEST));
      schedule.forEach((stop, index) => stop.stop = index + 1);
      const totalDuration = schedule.reduce((sum, s) => sum + s.durationMinutes, 0);
      if (schedule.length === 0) {
        return {
          id,
          name: inspector.fullName,
          color,
          start: inspector.homeCoords,
          stops: [],
          totalMiles: 0,
          totalDuration: 0,
          legs: []
        };
      }
      const routePoints = [{
        isHome: true,
        address: 'Home',
        locationCoords: inspector.homeCoords
      }, ...schedule, {
        isHome: true,
        address: 'Home',
        locationCoords: inspector.homeCoords,
        stop: 'Return'
      }];
      const legs = [];
      for (let i = 0; i < routePoints.length - 1; i++) {
        const origin = routePoints[i];
        const destination = routePoints[i + 1];
        const distance = calculateDistance(origin.locationCoords.lat, origin.locationCoords.lng, destination.locationCoords.lat, destination.locationCoords.lng);
        const estimatedTravelTime = (distance / AVERAGE_SPEED_MPH) * 60;
        let timeGap = 0;
        if (!origin.isHome && !destination.isHome) {
          const originEndTime = timeStringToMinutes(origin.timeEST) + origin.durationMinutes;
          const destinationStartTime = timeStringToMinutes(destination.timeEST);
          timeGap = destinationStartTime - originEndTime;
        }
        legs.push({
          legNumber: destination.isHome ? "Return Home" : `Leg ${destination.stop}`,
          origin,
          destination,
          distance,
          timeGap,
          estimatedTravelTime
        });
      }
      const totalMiles = legs.reduce((sum, leg) => sum + leg.distance, 0);
      return {
        id,
        name: inspector.fullName,
        color,
        start: inspector.homeCoords,
        stops: schedule,
        totalMiles,
        totalDuration,
        legs
      };
    });
    const getNumberEmoji = (num) => {
      const emojis = ['⓪', '①', '②', '③', '④', '⑤', '⑥', '⑦', '⑧', '⑨', '⑩'];
      if (num >= 0 && num <= 10) return emojis[num];
      return String(num).split('').map(digit => emojis[parseInt(digit)] || digit).join('');
    };
    const timeStringToMinutes = (timeStr) => {
      if (!timeStr || !timeStr.includes(':')) return 0;
      const [hours, minutes] = timeStr.split(':').map(Number);
      return hours * 60 + minutes;
    };
    const addMinutes = (time, mins) => {
      const date = new Date();
      const [hours, minutes] = time.split(':').map(Number);
      date.setHours(hours, minutes + mins, 0, 0);
      return date.toTimeString().slice(0, 5);
    };
    const minutesTo12HourFormat = (totalMinutes) => {
      if (isNaN(totalMinutes) || totalMinutes < 0) return 'N/A';
      const roundedTotalMinutes = Math.round(totalMinutes);
      const hours = Math.floor(roundedTotalMinutes / 60) % 24;
      const minutes = roundedTotalMinutes % 60;
      const h = hours;
      const suffix = h >= 12 ? 'PM' : 'AM';
      const formattedHours = ((h + 11) % 12 + 1);
      return `${formattedHours}:${String(minutes).padStart(2, '0')} ${suffix}`;
    };
    const formatTime12Hour = (time) => {
      if (!time) return 'N/A';
      const [hours, minutes] = time.split(':');
      const h = parseInt(hours);
      const suffix = h >= 12 ? 'PM' : 'AM';
      return `${((h + 11) % 12 + 1)}:${minutes.padStart(2, '0')} ${suffix}`;
    };
    const formatDuration = (totalMinutes) => {
      if (totalMinutes < 1) return '0m';
      const hours = Math.floor(totalMinutes / 60);
      const minutes = Math.round(totalMinutes % 60);
      let result = '';
      if (hours > 0) result += `${hours}h `;
      if (minutes > 0) result += `${minutes}m`;
      return result.trim();
    };
    const calculateDistance = (lat1, lon1, lat2, lon2) => {
      if (lat1 == null || lon1 == null || lat2 == null || lon2 == null) return 0;
      const R = 3958.8; // Radius of the Earth in miles
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLon = (lon2 - lon1) * Math.PI / 180;
      const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * Math.sin(dLon / 2) * Math.sin(dLon / 2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      return R * c;
    };
    const varToMs = (varName) => parseFloat(getComputedStyle(document.documentElement).getPropertyValue(varName)) * 1000;
    const formatInspectionType = (type) => {
      if (!type) return 'Unknown';
      return type.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
    };
    const formatDateForHeader = (date) => {
      const options = {
        weekday: 'long',
        year: 'numeric',
        month: 'long',
        day: 'numeric'
      };
      return date.toLocaleDateString('en-US', options);
    };
    const formatDateForExport = (date) => {
      const year = date.getFullYear();
      const month = String(date.getMonth() + 1).padStart(2, '0');
      const day = String(date.getDate()).padStart(2, '0');
      return `${year}-${month}-${day}`;
    };

    // --- TOOLTIP & COPY FUNCTIONALITY ---
    function generateCleanTextForTooltip(type, data) {
      switch (type) {
        case 'home':
          return `${data.person.name}'s Route\nDeparture: ${data.departureTime}\nFirst Stop: ${data.firstLeg.destination.address}\nSubject: ${data.firstLeg.destination.subject || 'Inspection'}\nArrival: ${data.firstInspectionTime}`;
        case 'stop':
          return `${data.s.subject || 'Inspection'}\n${data.s.address}\nInspector: ${data.person.name}\nTime: ${formatTime12Hour(data.s.timeEST)} - ${formatTime12Hour(addMinutes(data.s.timeEST, data.s.durationMinutes))}\nDuration: ${data.s.durationMinutes} min`;
        case 'leg':
          const originTime = data.leg.origin.isHome ? '' : `${formatTime12Hour(data.leg.origin.timeEST)} - ${formatTime12Hour(addMinutes(data.leg.origin.timeEST, data.leg.origin.durationMinutes))}`;
          const destTime = data.leg.destination.isHome ? '' : `${formatTime12Hour(data.leg.destination.timeEST)} - ${formatTime12Hour(addMinutes(data.leg.destination.timeEST, data.leg.destination.durationMinutes))}`;
          return `${data.person.name} - ${data.leg.legNumber}\nFrom: ${data.leg.origin.address} ${originTime}\nTo: ${data.leg.destination.address} ${destTime}\nTravel: ${formatDuration(Math.round(data.leg.estimatedTravelTime))}, Gap: ${formatDuration(data.leg.timeGap)}, Distance: ${data.leg.distance.toFixed(1)} mi`;
        default:
          return '';
      }
    }

    // --- NEW INTERACTIVE POPUP FUNCTION ---
    function setupInteractivePopup(layer, content, className = 'custom-popup') {
      const popup = L.popup({
        closeButton: true,
        autoClose: false,
        closeOnClick: false,
        className: className
      }).setContent(content);
      layer.bindPopup(popup);
      let popupEl = null;
      let isMouseOverLayer = false;
      const hidePopup = () => {
        setTimeout(() => {
          if (!isMouseOverLayer && popupEl && !popupEl.matches(':hover')) {
            layer.closePopup();
          }
        }, 150);
      };
      layer.on('mouseover', () => {
        isMouseOverLayer = true;
        layer.openPopup();
      });
      layer.on('mouseout', () => {
        isMouseOverLayer = false;
        hidePopup();
      });
      layer.on('popupopen', () => {
        popupEl = layer.getPopup().getElement();
        popupEl.addEventListener('mouseleave', () => {
          hidePopup();
        });
        // No need for mouseenter on the popupEl, as matches(':hover') handles it.
      });
    }

    // --- MAP & UI RENDERING ---
    const initializeMap = () => {
      if (document.getElementById('map')) {
        map = L.map('map', {
          zoomControl: false,
          zoomSnap: 0.1,
          zoomDelta: 0.25
        }).setView([28.5383, -81.3792], 8);
        L.control.zoom({
          position: 'bottomright'
        }).addTo(map);
        schedulerLayerGroup.addTo(map);
        changeMapStyle('dark');
        return true;
      }
      return false;
    };
    const changeMapStyle = (style) => {
      if (!map) return;
      const mapEl = document.getElementById('map');
      if (currentMapLayers) currentMapLayers.forEach(layer => map.removeLayer(layer));
      currentMapLayers = [];
      mapEl.classList.remove('dark-map-active');
      let layerUrl, attribution;
      if (style === 'dark') {
        mapEl.classList.add('dark-map-active');
        layerUrl = `https://tiles.stadiamaps.com/tiles/alidade_smooth_dark/{z}/{x}/{y}{r}.png?api_key=${STADIA_API_KEY}`;
        attribution = '© Stadia Maps, © OpenMapTiles, © OSM';
      } else if (style === 'satellite') {
        layerUrl = 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}';
        attribution = '© Esri';
      } else {
        layerUrl = 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png';
        attribution = '© OpenStreetMap contributors';
      }
      const newLayer = L.tileLayer(layerUrl, {
        attribution: attribution,
        maxZoom: 19
      });
      map.addLayer(newLayer);
      currentMapLayers.push(newLayer);
      Object.values(personLayersData).forEach(data => {
        const newOpacity = (style === 'dark') ? 0 : 0.4;
        if (data.legLayers) {
          data.legLayers.forEach(leg => leg.casing.setStyle({
            opacity: newOpacity
          }));
        }
      });
    };
    const renderRoutesAndLegend = (appData) => {
      if (!map) return;
      const legendContainer = document.getElementById('legend-items-container');
      legendContainer.innerHTML = '';
      peopleRouteData.forEach(person => {
        if (person.stops.length === 0) return;
        const group = L.layerGroup();
        const stopMarkers = [];
        const permanentLabels = [];
        const legLayers = [];
        const allPoints = [person.start, ...person.stops.map(s => s.locationCoords)];
        const firstLeg = person.legs[0];
        const firstStopTime = timeStringToMinutes(firstLeg.destination.timeEST);
        const departureTimeInMinutes = firstStopTime - firstLeg.estimatedTravelTime;
        const departureTime = minutesTo12HourFormat(departureTimeInMinutes);
        const firstInspectionTime = formatTime12Hour(firstLeg.destination.timeEST);
        const cleanHomeText = generateCleanTextForTooltip('home', {
          person,
          firstLeg,
          departureTime,
          firstInspectionTime
        });
        const homePopupContent = `<div class="tooltip-header"><b class="title">${person.name}'s Route</b><button class="copy-tooltip-btn" data-copy-text="${cleanHomeText.replace(/"/g, '"')}">📋</button></div>${firstLeg.origin.address}<hr><b>Departure:</b> ${departureTime}<br><b>First Stop:</b> ${firstLeg.destination.address}<br><b>Subject:</b> ${firstLeg.destination.subject || 'Inspection'}<br><b>Arrival:</b> ${firstInspectionTime}`;
        const homeMarker = L.marker(person.start, {
            icon: L.divIcon({
              html: `<div class="stop-marker home-marker"><span>🏠</span></div>`,
              className: '',
              iconSize: [20, 20],
              iconAnchor: [10, 20]
            })
          })
          .addTo(group);
        setupInteractivePopup(homeMarker, homePopupContent);
        person.legs.forEach((leg, index) => {
          const legPoints = [leg.origin.locationCoords, leg.destination.locationCoords];
          const casing = L.polyline(legPoints, {
            color: 'black',
            weight: 4.2,
            opacity: 0,
            dashArray: '8, 8'
          }).addTo(group);
          const line = L.polyline(legPoints, {
            color: person.color,
            weight: 2.2,
            opacity: 0.9,
            dashArray: '8, 8'
          }).addTo(group);
          const hoverArea = L.polyline(legPoints, {
            color: 'transparent',
            weight: 40,
            interactive: true
          }).addTo(group);
          const originTime = leg.origin.isHome ? '' : `<div class="time">${formatTime12Hour(leg.origin.timeEST)} - ${formatTime12Hour(addMinutes(leg.origin.timeEST, leg.origin.durationMinutes))}</div>`;
          const destTime = leg.destination.isHome ? '' : `<div class="time">${formatTime12Hour(leg.destination.timeEST)} - ${formatTime12Hour(addMinutes(leg.destination.timeEST, leg.destination.durationMinutes))}</div>`;
          const timeGapInfo = leg.timeGap > 0 ? `${formatDuration(leg.timeGap)}` : ``;
          const cleanLegText = generateCleanTextForTooltip('leg', {
            person,
            leg
          });
          const legPopupContent = `<div class="leg-tooltip-header"><div class="leg-tooltip-header-main"><div class="name">${person.name}</div><button class="copy-tooltip-btn" data-copy-text="${cleanLegText.replace(/"/g, '"')}">📋</button></div><div class="leg-title">${leg.legNumber}</div></div><div class="leg-tooltip-body"><div class="leg-tooltip-row"><div class="leg-tooltip-icon">⤴️</div><div class="leg-tooltip-content"><div class="address"><b>From:</b> ${leg.origin.address}</div>${originTime}</div></div><div class="leg-tooltip-row"><div class="leg-tooltip-icon">⤵️</div><div class="leg-tooltip-content"><div class="address"><b>To:</b> ${leg.destination.address}</div>${destTime}</div></div></div><div class="leg-tooltip-footer"><div class="leg-tooltip-footer-item">Travel: ${formatDuration(Math.round(leg.estimatedTravelTime))}</div><div class="leg-tooltip-footer-item">Gap: ${timeGapInfo}</div><div class="leg-tooltip-footer-item">📍 ${leg.distance.toFixed(1)} mi</div></div>`;
          setupInteractivePopup(hoverArea, legPopupContent, 'leg-popup');
          hoverArea.on('mouseover', () => {
            clearTimeout(tooltipHideTimeout);
            exitTabFocus(true);
            highlightSegment(person.id, line);
          });
          hoverArea.on('mouseout', () => {
            tooltipHideTimeout = setTimeout(resetRouteHighlights, 300);
          });
          legLayers.push({
            line,
            casing,
            hoverArea
          });
        });
        person.stops.forEach((s, index) => {
          const marker = L.marker(s.locationCoords, {
            icon: L.divIcon({
              html: `<div style="border-color:${person.color};" class="stop-marker"><span>${s.stop}</span></div>`,
              className: '',
              iconSize: [20, 20],
              iconAnchor: [10, 20]
            })
          });
          const cleanStopText = generateCleanTextForTooltip('stop', {
            s,
            person
          });
          const stopPopupContent = `<div class="tooltip-header"><b class="title">${s.subject || 'Inspection'}</b><button class="copy-tooltip-btn" data-copy-text="${cleanStopText.replace(/"/g, '"')}">📋</button></div>${s.address}<hr><b>Inspector:</b> ${person.name}<br><b>Time:</b> ${formatTime12Hour(s.timeEST)} - ${formatTime12Hour(addMinutes(s.timeEST, s.durationMinutes))}<br><b>Duration:</b> ${s.durationMinutes} min`;
          setupInteractivePopup(marker, stopPopupContent);
          marker.addTo(group);
          stopMarkers.push(marker);
          const direction = index % 2 === 0 ? 'right' : 'left';
          const offset = direction === 'right' ? [15, 0] : [-15, 0];
          const labelContent = `<div><span class="tooltip-stop-number">${s.stop}</span>${s.address}</div>`;
          const label = L.tooltip({
            permanent: true,
            direction: direction,
            offset: offset,
            className: 'static-address-label'
          }).setLatLng(s.locationCoords).setContent(labelContent);
          permanentLabels.push(label);
        });
        personLayersData[person.id] = {
          group,
          legLayers,
          stopMarkers,
          allPoints,
          isVisible: true,
          color: person.color,
          totalMiles: person.totalMiles,
          totalDuration: person.totalDuration,
          permanentLabels: permanentLabels
        };
        map.addLayer(group);
        const legendItem = document.createElement('div');
        legendItem.className = 'legend-item';
        legendItem.dataset.personId = person.id;
        legendItem.innerHTML = `
                    <div class="legend-item-header">
                        <div class="legend-item-info">
                            <div class="color-box" style="background-color:${person.color};"></div>
                            <div class="legend-item-data">
                                <div class="name-stops-row">
                                    <div class="name">${person.name}</div>
                                    <div class="detail-point stops-count">${person.stops.length} Stops</div>
                                </div>
                                <div class="details">
                                    <div class="detail-point">🚚 ${person.totalMiles.toFixed(1)} mi</div>
                                    <div class="detail-point">⏱️ ${formatDuration(person.totalDuration)}</div>
                                </div>
                            </div>
                        </div>
                        <div class="legend-item-controls">
                             <button class="control-btn focus-btn" title="Focus Route">📍</button>
                             <button class="control-btn visibility-btn is-active" title="Toggle Route">👁️</button>
                             <button class="control-btn gmaps-btn" title="Google Maps">🗺️</button>
                             <button class="control-btn calendar-btn" title="View Calendar">📅</button>
                             <div class="control-group-separator"></div>
                        </div>
                    </div>`;
        legendContainer.appendChild(legendItem);
        legendItem.addEventListener('click', () => {
          enterFocusMode(person.id);
          showInspectorInfo(person.id, appData);
        });
        legendItem.addEventListener('mouseenter', () => {
          clearTimeout(tooltipHideTimeout);
          exitTabFocus(true);
          highlightRoute(person.id, true);
        });
        legendItem.addEventListener('mouseleave', () => {
          tooltipHideTimeout = setTimeout(resetRouteHighlights, 300);
        });
        legendItem.querySelector('.calendar-btn').addEventListener('click', e => {
          e.stopPropagation();
          window.open(`https://toptier.pipedrive.com/activities/calendar/user/${person.id}`, '_blank');
        });
        legendItem.querySelector('.gmaps-btn').addEventListener('click', e => {
          e.stopPropagation();
          generateGoogleMapsLink(person.id);
        });
        legendItem.querySelector('.visibility-btn').addEventListener('click', e => {
          e.stopPropagation();
          togglePersonVisibility(person.id);
        });
        legendItem.querySelector('.focus-btn').addEventListener('click', e => {
          e.stopPropagation();
          enterFocusMode(person.id);
          showInspectorInfo(person.id, appData);
        });
      });
      updateMasterSegmentList();
      updateSummary();
    };
    const updateSummary = () => {
      const summaryEl = document.getElementById('legend-summary');
      if (!summaryEl) return;
      const visibleLayers = Object.values(personLayersData).filter(p => p.isVisible);
      const totalRoutes = peopleRouteData.filter(p => p.stops.length > 0).length;
      const visibleCount = visibleLayers.length;
      const totalStops = visibleLayers.reduce((sum, p) => sum + p.stopMarkers.length, 0);
      const totalMiles = visibleLayers.reduce((sum, p) => sum + p.totalMiles, 0);
      const totalDuration = visibleLayers.reduce((sum, p) => sum + p.totalDuration, 0);
      summaryEl.innerHTML = `<div id="legend-summary" style="width:100%"><table cellpadding="0" cellspacing="0" border="0" class="legend-table" style="width: 100%; table-layout: fixed; "><tr style="width:100%"><td>${visibleCount}/${totalRoutes} Routes</td><td>${totalStops} Stops</td><td>${totalMiles.toFixed(1)} mi</td><td>${formatDuration(totalDuration)}</td></tr></table></div>`;
    };
    const animateAllPolylines = () => {
      animationFrameCount++;
      if (animationFrameCount % 4 === 0) {
        Object.values(personLayersData).forEach(data => {
          if (data.isVisible) {
            data.legLayers.forEach(leg => {
              if (map.hasLayer(leg.line)) {
                let offset = parseInt(leg.line.options.dashOffset || 0);
                offset--;
                leg.line.setStyle({
                  dashOffset: offset
                });
                leg.casing.setStyle({
                  dashOffset: offset
                });
              }
            });
          }
        });
      }
      requestAnimationFrame(animateAllPolylines);
    };

    // --- UI INTERACTIVITY & FOCUS ---
    const highlightRoute = (personId, isHighlighted) => {
      map.dragging.disable();
      Object.keys(personLayersData).forEach(pId => {
        const ld = personLayersData[pId];
        if (!ld.isVisible) return;
        const opacity = isHighlighted ? (pId === personId ? 1.0 : 0.25) : 0.9;
        const casingDefaultOpacity = document.getElementById('map-style-select').value === 'dark' ? 0 : 0.4;
        const casingOpacity = isHighlighted ? (pId === personId ? 0.5 : 0.1) : casingDefaultOpacity;
        ld.legLayers.forEach(leg => {
          leg.line.setStyle({
            opacity: opacity
          });
          leg.casing.setStyle({
            opacity: casingOpacity
          });
        });
        ld.stopMarkers.forEach(m => m.getElement().style.opacity = opacity);
      });
    };
    const highlightSegment = (personId, segmentLine) => {
      map.dragging.disable();
      Object.keys(personLayersData).forEach(pId => {
        const ld = personLayersData[pId];
        if (!ld.isVisible) return;
        const isThisPerson = pId === personId;
        const casingDefaultOpacity = document.getElementById('map-style-select').value === 'dark' ? 0 : 0.4;
        ld.legLayers.forEach(leg => {
          const isThisSegment = leg.line === segmentLine;
          const opacity = isThisSegment ? 1.0 : 0.25;
          const casingOpacity = isThisSegment ? 0.5 : (casingDefaultOpacity * 0.5);
          leg.line.setStyle({
            opacity: opacity
          });
          leg.casing.setStyle({
            opacity: casingOpacity
          });
        });
        ld.stopMarkers.forEach(m => m.getElement().style.opacity = isThisPerson ? 1.0 : 0.25);
      });
    };
    const resetRouteHighlights = () => {
      map.dragging.enable();
      Object.keys(personLayersData).forEach(pId => {
        const ld = personLayersData[pId];
        if (!ld.isVisible) return;
        const casingOpacity = document.getElementById('map-style-select').value === 'dark' ? 0 : 0.4;
        ld.legLayers.forEach(leg => {
          leg.line.setStyle({
            opacity: 0.9
          });
          leg.casing.setStyle({
            opacity: casingOpacity
          });
        });
        ld.stopMarkers.forEach(m => m.getElement().style.opacity = 0.9);
      });
    };
    const togglePersonVisibility = (id) => {
      exitTabFocus();
      const personData = personLayersData[id];
      if (!personData) return;
      personData.isVisible = !personData.isVisible;
      if (personData.isVisible) map.addLayer(personData.group);
      else map.removeLayer(personData.group);
      const item = document.querySelector(`.legend-item[data-person-id="${id}"]`);
      if (item) {
        item.querySelector('.visibility-btn').classList.toggle('is-active', personData.isVisible);
        item.classList.toggle('is-hidden');
      }
      updateMasterSegmentList();
      updateSummary();
    };
    const updateMasterSegmentList = () => {
      masterSegmentList = [];
      peopleRouteData.forEach(person => {
        const personData = personLayersData[person.id];
        if (personData && personData.isVisible) {
          personData.legLayers.forEach(leg => {
            masterSegmentList.push({
              personId: person.id,
              line: leg.line,
              hoverArea: leg.hoverArea
            });
          });
        }
      });
    };
    const exitTabFocus = (softExit = false) => {
      if (!isTabFocusActive) return;
      if (tabFocusIndex > -1 && masterSegmentList[tabFocusIndex]) {
        masterSegmentList[tabFocusIndex].hoverArea.closeTooltip();
      }
      isTabFocusActive = false;
      tabFocusIndex = -1;
      if (softExit) return;
      if (focusedPersonId) {
        highlightRoute(focusedPersonId, true);
        fitRoute(focusedPersonId);
      } else {
        resetRouteHighlights();
      }
      map.dragging.enable();
    };
    const handleKeyDown = (e) => {
      if (e.key === 'Escape') {
        exitTabFocus();
      }
      if (e.key === 'Tab') {
        e.preventDefault();
        if (masterSegmentList.length === 0) return;
        if (tabFocusIndex > -1 && masterSegmentList[tabFocusIndex]) {
          masterSegmentList[tabFocusIndex].hoverArea.closeTooltip();
        }
        isTabFocusActive = true;
        tabFocusIndex = (tabFocusIndex + 1) % masterSegmentList.length;
        const currentSegment = masterSegmentList[tabFocusIndex];
        if (currentSegment) {
          highlightSegment(currentSegment.personId, currentSegment.line);
          currentSegment.hoverArea.openTooltip();
          map.panTo(currentSegment.line.getCenter());
        }
      }
    };
    const enterFocusMode = (id) => {
      exitTabFocus();
      const focusBtn = document.querySelector(`.legend-item[data-person-id="${id}"] .focus-btn`);
      if (isInFocusMode && focusBtn && focusBtn.classList.contains('is-active')) {
        exitFocusMode();
        hideInspectorInfo();
        return;
      }
      if (isInFocusMode) exitFocusMode(true);
      isInFocusMode = true;
      focusedPersonId = id;
      document.body.classList.add('focus-mode-active');
      Object.keys(personLayersData).forEach(pId => {
        const isThisOne = pId === id;
        const ld = personLayersData[pId];
        if (isThisOne) {
          if (!ld.isVisible) {
            ld.isVisible = true;
            const item = document.querySelector(`.legend-item[data-person-id="${pId}"]`);
            if (item) {
              item.querySelector('.visibility-btn').classList.add('is-active');
              item.classList.remove('is-hidden');
            }
          }
          if (!map.hasLayer(ld.group)) map.addLayer(ld.group);
        } else {
          if (map.hasLayer(ld.group)) map.removeLayer(ld.group);
        }
        if (isThisOne && tooltipsVisibleInFocus) {
          ld.permanentLabels.forEach(label => map.addLayer(label));
        } else {
          ld.permanentLabels.forEach(label => map.removeLayer(label));
        }
        const item = document.querySelector(`.legend-item[data-person-id="${pId}"] .focus-btn`);
        if (item) item.classList.toggle('is-active', isThisOne);
      });
      fitRoute(id);
      updateSummary();
    };
    const exitFocusMode = (silent = false) => {
      exitTabFocus(true);
      if (!isInFocusMode) return;
      if (focusedPersonId && personLayersData[focusedPersonId]) {
        personLayersData[focusedPersonId].permanentLabels.forEach(label => map.removeLayer(label));
      }
      isInFocusMode = false;
      focusedPersonId = null;
      document.body.classList.remove('focus-mode-active');
      Object.values(personLayersData).forEach(ld => {
        if (ld.isVisible && !map.hasLayer(ld.group)) map.addLayer(ld.group);
        else if (!ld.isVisible && map.hasLayer(ld.group)) map.removeLayer(ld.group);
      });
      document.querySelectorAll('.focus-btn.is-active').forEach(btn => btn.classList.remove('is-active'));
      if (!silent) fitAllVisibleRoutes();
      updateSummary();
      tooltipsVisibleInFocus = true;
    };
    const showInspectorInfo = (id, appData) => {
      const person = peopleRouteData.find(p => p.id === id);
      if (!person) return;
      lastOpenPanel = 'info';
      const infoPanel = document.getElementById('info-panel');
      let stopsHtml = '';
      person.legs.forEach(leg => {
        if (leg.destination.isHome) return;
        const stop = leg.destination;
        const startTime12 = formatTime12Hour(stop.timeEST);
        const endTime12 = formatTime12Hour(addMinutes(stop.timeEST, stop.durationMinutes));
        const lockedToUser = stop.lockedToUser && appData.inspectors[stop.lockedToUser] ? appData.inspectors[stop.lockedToUser].fullName : null;
        stopsHtml += `
                    <div class="stop-card">
                        <div class="stop-header">
                            <div class="stop-number" style="border-color:${person.color};">${stop.stop}</div>
                            <div class="stop-address"><a href="http://googleusercontent.com/maps.google.com/3{stop.locationCoords.lat},${stop.locationCoords.lng}" target="_blank" title="View on Google Maps">${stop.address}</a></div>
                        </div>
                        <div class="stop-details-grid">
                            <div class="pipedrive-links">
                                <span class="link-item"><b>Activity ID:</b> <a href="https://toptier.pipedrive.com/activities/list?activity=${stop.activityId}#dialog/activity/edit" target="_blank">${stop.activityId}</a></span>
                                <span class="link-item"><b>Deal ID:</b> <a href="https://toptier.pipedrive.com/deal/${stop.dealId}" target="_blank">${stop.dealId}</a></span>
                            </div>
                            <div class="stop-subject">${stop.subject || 'No Subject'}</div>
                            <div class="stop-attributes">
                                <div class="stop-detail-item"><span class="icon">📋</span> ${formatInspectionType(stop.type)}</div>
                                <div class="stop-detail-item"><span class="icon">🕒</span> ${startTime12} - ${endTime12} (${stop.durationMinutes} min)</div>
                                <div class="stop-detail-item"><span class="icon">🚚</span> ${leg.distance.toFixed(1)} mi from prior</div>
                                <div class="stop-detail-item"><span class="icon">🏠</span> Interior: <span class="interior-badge ${stop.interior}">${stop.interior ? 'Yes' : 'No'}</span></div>
                                ${lockedToUser ? `<div class="stop-detail-item"><span class="icon">🔒</span> Locked to ${lockedToUser}</div>` : ''}
                            </div>
                        </div>
                    </div>`;
      });
      infoPanel.innerHTML = `<div class="info-panel-header"><button id="close-info-panel-btn" title="Back to All Inspectors"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><path d="M19 12H5M12 19l-7-7 7-7"/></svg></button><h2 class="name">${person.name}</h2><button id="toggle-tooltips-btn" class="is-active" title="Toggle Stop Labels">🏷️</button></div><div class="info-panel-body">${stopsHtml}</div><div class="info-panel-footer"><div class="export-buttons"><button onclick="exportCSV('${person.id}')" class="custom-btn btn-blue">Export Route CSV</button><button onclick="exportPNG()" class="custom-btn btn-blue">Export Route PNG</button></div><button id="exit-focus-btn-panel" class="exit-focus-btn" style="display: block;">✖ Exit Focus</button></div>`;
      document.body.classList.add('info-panel-active');
      infoPanel.classList.add('is-visible');
      document.getElementById('close-info-panel-btn').onclick = hideInspectorInfo;
      document.getElementById('toggle-tooltips-btn').onclick = () => toggleTooltipsInFocus(id);
      document.getElementById('toggle-tooltips-btn').classList.toggle('is-active', tooltipsVisibleInFocus);
      document.getElementById('exit-focus-btn-panel').onclick = () => {
        exitFocusMode();
        hideInspectorInfo();
      };
      const legend = document.getElementById('legend');
      if (legend.classList.contains('is-open')) {
        legend.classList.remove('is-open');
        updateMenuButtonState();
      }
      setTimeout(() => map.invalidateSize(), varToMs('--transition-speed'));
    };
    const hideInspectorInfo = () => {
      document.body.classList.remove('info-panel-active');
      document.getElementById('info-panel').classList.remove('is-visible');
      exitFocusMode();
      setTimeout(() => map.invalidateSize(), varToMs('--transition-speed'));
      lastOpenPanel = 'legend';
      if (window.innerWidth <= 900) {
        updateMenuButtonState();
      }
    };
    const toggleTooltipsInFocus = (id) => {
      tooltipsVisibleInFocus = !tooltipsVisibleInFocus;
      const personData = personLayersData[id];
      if (personData) {
        if (tooltipsVisibleInFocus) {
          personData.permanentLabels.forEach(label => map.addLayer(label));
        } else {
          personData.permanentLabels.forEach(label => map.removeLayer(label));
        }
      }
      const btn = document.getElementById('toggle-tooltips-btn');
      if (btn) btn.classList.toggle('is-active', tooltipsVisibleInFocus);
    };
    const generateGoogleMapsLink = (personId) => {
      const person = peopleRouteData.find(p => p.id === personId);
      if (!person || person.stops.length === 0) return;
      const origin = `${person.start.lat},${person.start.lng}`;
      const destination = origin;
      const waypoints = person.stops.map(stop => `${stop.locationCoords.lat},${stop.locationCoords.lng}`).join('|');
      const mapsUrl = `https://www.google.com/maps/dir/?api=1&origin=${origin}&destination=${destination}&waypoints=${waypoints}`;
      window.open(mapsUrl, '_blank');
    };
    const flyToBounds = (bounds) => {
      if (map && bounds.isValid()) {
        map.invalidateSize();
        map.fitBounds(bounds, {
          padding: [30, 30],
          maxZoom: 16
        });
      }
    };
    const fitRoute = (id) => {
      if (personLayersData[id]) flyToBounds(L.latLngBounds(personLayersData[id].allPoints));
    };
    const fitAllVisibleRoutes = () => {
      const bounds = L.latLngBounds();
      Object.values(personLayersData).forEach(p => {
        if (p.isVisible && p.allPoints.length > 1) p.allPoints.forEach(pt => bounds.extend(pt));
      });
      if (bounds.isValid()) flyToBounds(bounds);
    };

    // --- EXPORT & MODALS ---
    function createPngLegendHTML() {
      const shortenAddress = (addr) => addr ? addr.split(', FL')[0] : 'N/A';
      if (isInFocusMode && focusedPersonId) {
        const person = peopleRouteData.find(p => p.id === focusedPersonId);
        if (!person) return '';
        let stopsHTML = person.stops.map(s => `<div class="png-legend-stop-item"><span class="stop-num-icon">${getNumberEmoji(s.stop)}</span> <b>${formatTime12Hour(s.timeEST)}</b> - ${shortenAddress(s.address)}</div>`).join('');
        return `<div class="png-legend-title" style="display: flex; align-items: center;"><div class="color-box" style="background-color:${person.color}; margin-right: 8px;"></div>${person.name}'s Route</div>${stopsHTML}`;
      } else {
        let itemsHTML = peopleRouteData
          .filter(p => personLayersData[p.id] && personLayersData[p.id].isVisible && p.stops.length > 0)
          .map(p => {
            return `<div class="png-legend-item"><div class="color-box" style="background-color:${p.color};"></div><span>${p.name}</span></div>`;
          }).join('');
        return `<div class="png-legend-title">Inspector Legend</div>${itemsHTML}`;
      }
    }
    async function exportPNG() {
      const legendContainer = document.getElementById('png-legend-container');
      const mapContainer = document.getElementById('map-container');
      const originalBg = mapContainer.style.backgroundColor;
      mapContainer.style.backgroundColor = '#1a1a1a';
      legendContainer.innerHTML = createPngLegendHTML();
      legendContainer.style.display = 'block';
      try {
        const dataUrl = await domtoimage.toPng(mapContainer, {
          quality: 0.95
        });
        const link = document.createElement('a');
        let filename = 'ttpa-map-export.png';
        if (isInFocusMode && focusedPersonId) {
          const person = peopleRouteData.find(p => p.id === focusedPersonId);
          if (person) filename = `ttpa-route-${person.name.replace(/\s+/g, '_')}.png`;
        }
        link.download = filename;
        link.href = dataUrl;
        link.click();
      } catch (error) {
        console.error('PNG export failed:', error);
      } finally {
        legendContainer.style.display = 'none';
        legendContainer.innerHTML = '';
        mapContainer.style.backgroundColor = originalBg;
      }
    }

    function exportCSV(personId = null) {
      let dataToExport;
      let filename = "ttpa_all_routes_comprehensive.csv";
      if (personId) {
        dataToExport = peopleRouteData.filter(p => p.id === personId);
        if (dataToExport.length > 0) {
          filename = `ttpa_route_${dataToExport[0].name.replace(/\s+/g, '_')}_comprehensive.csv`;
        }
      } else {
        dataToExport = peopleRouteData.filter(p => personLayersData[p.id] && personLayersData[p.id].isVisible);
      }
      if (dataToExport.length === 0) {
        alert("No visible routes to export.");
        return;
      }
      const headers = [
        "InspectorName", "InspectorID", "RouteDate", "StopNumber", "Address", "Latitude", "Longitude",
        "InspectionSubject", "InspectionType", "Interior", "ScheduledStartTime", "ScheduledEndTime", "Duration(min)",
        "PipedriveActivityID", "PipedriveDealID", "TravelDistFromPrev(mi)", "TravelTimeFromPrev(min)", "IdleTimeBeforeStop(min)"
      ];
      const escapeCsvCell = (cell) => {
        const strCell = String(cell === null || cell === undefined ? '' : cell);
        if (strCell.includes(',')) {
          return `"${strCell.replace(/"/g, '""')}"`;
        }
        return strCell;
      };
      const today = formatDateForExport(new Date());
      let csvRows = [headers.join(',')];
      dataToExport.forEach(person => {
        if (person.stops.length > 0) {
          person.legs.forEach(leg => {
            if (leg.destination.isHome) return;
            const stop = leg.destination;
            const row = [
              person.name,
              person.id,
              today,
              stop.stop,
              stop.address,
              stop.locationCoords.lat,
              stop.locationCoords.lng,
              stop.subject,
              formatInspectionType(stop.type),
              stop.interior ? 'Yes' : 'No',
              stop.timeEST,
              addMinutes(stop.timeEST, stop.durationMinutes),
              stop.durationMinutes,
              stop.activityId,
              stop.dealId,
              leg.distance.toFixed(2),
              Math.round(leg.estimatedTravelTime),
              Math.round(Math.max(0, leg.timeGap - leg.estimatedTravelTime))
            ];
            csvRows.push(row.map(escapeCsvCell).join(','));
          });
        }
      });
      const csvContent = "data:text/csv;charset=utf-8," + csvRows.join('\r\n');
      const link = document.createElement("a");
      link.setAttribute("href", encodeURI(csvContent));
      link.setAttribute("download", filename);
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }
    const initializeSpecialButtonsAndModals = (appData) => {
      const buttonsContainer = document.getElementById('special-info-buttons');
      buttonsContainer.innerHTML = '';
      const {
        timeAdjustments,
        conflicts: schedulingConflicts,
        dataIssues
      } = appData;
      const schedulerBtn = document.createElement('button');
      schedulerBtn.className = 'special-btn btn-blue';
      schedulerBtn.innerHTML = `📲 Find Available Inspector`;
      schedulerBtn.onclick = () => showModal('scheduler-modal');
      buttonsContainer.appendChild(schedulerBtn);
      if (dataIssues && dataIssues.length > 0) {
        const btn = document.createElement('button');
        btn.className = 'special-btn btn-info';
        btn.innerHTML = `Data Issues <span class="badge">${dataIssues.length}</span>`;
        btn.onclick = () => showModal('data-issues-modal');
        buttonsContainer.appendChild(btn);
        populateDataIssuesModal(dataIssues);
      }
      if (timeAdjustments && timeAdjustments.length > 0) {
        const btn = document.createElement('button');
        btn.className = 'special-btn';
        btn.innerHTML = `Time Adjustments <span class="badge">${timeAdjustments.length}</span>`;
        btn.onclick = () => showModal('adjustments-modal');
        buttonsContainer.appendChild(btn);
        populateAdjustmentsModal(timeAdjustments, appData);
      }
      if (schedulingConflicts && schedulingConflicts.length > 0) {
        const btn = document.createElement('button');
        btn.className = 'special-btn btn-warning';
        btn.innerHTML = `Conflicts <span class="badge">${schedulingConflicts.length}</span>`;
        btn.onclick = () => showModal('unassigned-modal');
        buttonsContainer.appendChild(btn);
        populateUnassignedModal(schedulingConflicts);
      }
      document.querySelectorAll('.modal-close-btn').forEach(btn => btn.onclick = () => {
        const modal = btn.closest('.modal-overlay');
        if (modal) hideModal(modal.id);
      });
      document.querySelectorAll('.modal-overlay').forEach(overlay => overlay.onclick = (e) => {
        if (e.target === overlay) {
          hideModal(overlay.id);
          schedulerLayerGroup.clearLayers();
        }
      });
      document.getElementById('check-availability-btn').addEventListener('click', findAvailableInspectors);
      document.getElementById('geocode-btn').addEventListener('click', geocodeAddress);
    };
    const showModal = (modalId) => {
      const modal = document.getElementById(modalId);
      if (modal) modal.classList.add('is-visible');
    };
    const hideModal = (modalId) => {
      const modal = document.getElementById(modalId);
      if (modal) modal.classList.remove('is-visible');
      if (modalId === 'scheduler-modal') {
        schedulerLayerGroup.clearLayers();
      }
    };
    const populateAdjustmentsModal = (adjustments, appData) => {
      const tableBody = document.querySelector('#adjustments-table tbody');
      tableBody.innerHTML = '';
      adjustments.forEach(adj => {
        const inspectorName = appData.inspectors[adj.assignedInspectorId]?.fullName || 'Unknown';
        tableBody.innerHTML += `<tr><td>${inspectorName}</td><td>${formatTime12Hour(adj.originalTimeEST)}</td><td>${formatTime12Hour(adj.newTimeEST)}</td><td>${adj.reason}</td></tr>`;
      });
    };
    const populateUnassignedModal = (conflicts) => {
      const tableBody = document.querySelector('#unassigned-table tbody');
      tableBody.innerHTML = '';
      conflicts.forEach(item => {
        tableBody.innerHTML += `<tr><td>${item.activityId}</td><td>${item.address || 'N/A'}</td><td>${item.reason}</td></tr>`;
      });
    };
    const populateDataIssuesModal = (issues) => {
      const tableBody = document.querySelector('#data-issues-table tbody');
      tableBody.innerHTML = '';
      issues.forEach(item => {
        const activityLink = `<a href="https://toptier.pipedrive.com/activities/list?activity=${item.activityId}#dialog/activity/edit" target="_blank">${item.activityId}</a>`;
        const dealLink = `<a href="https://toptier.pipedrive.com/deal/${item.dealId}" target="_blank">${item.dealId}</a>`;
        tableBody.innerHTML += `<tr><td>${activityLink}</td><td>${dealLink}</td><td>${item.address || 'N/A'}</td><td>${item.reason}</td></tr>`;
      });
    };

    function geocodeAddress() {
      const address = document.getElementById('new-inspection-address').value;
      if (!address) {
        alert("Please enter an address.");
        return;
      }
      // Simulate finding a location in the Orlando area: 28.6338° N, 81.3685° W
      const lat = 28.6338 + (Math.random() - 0.5) * 0.5;
      const lng = -81.3685 + (Math.random() - 0.5) * 0.5;
      const location = {
        lat,
        lng
      };
      schedulerLayerGroup.clearLayers();
      const newInspectionIcon = L.divIcon({
        html: `<div style="font-size: 2rem;">📍</div>`,
        className: '',
        iconSize: [32, 32],
        iconAnchor: [16, 32]
      });
      L.marker(location, {
          icon: newInspectionIcon,
          zIndexOffset: 1000,
          isNewInspection: true
        })
        .addTo(schedulerLayerGroup)
        .bindTooltip(`Proposed Inspection: <br><b>${address}</b>`, {
          permanent: true,
          direction: 'top'
        });
      map.flyTo(location, 11);
      document.getElementById('new-inspection-address').dataset.lat = lat;
      document.getElementById('new-inspection-address').dataset.lng = lng;
    }
    const getInspectorStateAtTime = (person, timeInMinutes) => {
      if (!person.stops || person.stops.length === 0) {
        return {
          status: "AT_OFFICE",
          location: OFFICE_COORDS,
          details: "At Office (Overflow)"
        };
      }
      let firstDepartureTime = timeStringToMinutes(person.legs[0].destination.timeEST) - person.legs[0].estimatedTravelTime;
      if (timeInMinutes < firstDepartureTime) {
        return {
          status: "AT_HOME",
          location: person.start,
          details: `At home. Must leave by ${minutesTo12HourFormat(firstDepartureTime)} for first inspection.`
        };
      }
      for (let i = 0; i < person.legs.length; i++) {
        const leg = person.legs[i];
        const origin = leg.origin;
        const destination = leg.destination;
        if (destination.isHome) {
          const lastArrival = timeStringToMinutes(origin.timeEST) + origin.durationMinutes + leg.estimatedTravelTime;
          if (timeInMinutes >= lastArrival) {
            return {
              status: "AT_HOME",
              location: person.start,
              details: "Route complete for the day."
            };
          }
        }
        if (!destination.isHome) {
          const stopStartTime = timeStringToMinutes(destination.timeEST);
          const stopEndTime = stopStartTime + destination.durationMinutes;
          if (timeInMinutes >= stopStartTime && timeInMinutes < stopEndTime) {
            const nextStop = person.stops[destination.stop] || null;
            const nextStopInfo = nextStop ? `Next is at ${formatTime12Hour(nextStop.timeEST)}.` : "This is the last stop.";
            return {
              status: "ON_INSPECTION",
              location: destination.locationCoords,
              details: `On inspection until ${minutesTo12HourFormat(stopEndTime)}. ${nextStopInfo}`
            };
          }
        }
        const prevStopEndTime = origin.isHome ? firstDepartureTime : timeStringToMinutes(origin.timeEST) + origin.durationMinutes;
        const nextStopTime = destination.isHome ? Infinity : timeStringToMinutes(destination.timeEST);
        if (timeInMinutes >= prevStopEndTime && timeInMinutes < nextStopTime) {
          const travelStarts = nextStopTime - leg.estimatedTravelTime;
          if (timeInMinutes < travelStarts) {
            const gapEnd = minutesTo12HourFormat(travelStarts);
            const gapDuration = formatDuration(travelStarts - prevStopEndTime);
            return {
              status: "IDLE_GAP",
              location: origin.locationCoords,
              details: `Available at ${origin.address} until approx. ${gapEnd} (${gapDuration} gap).`
            };
          } else {
            const travelDuration = timeInMinutes - travelStarts;
            const travelRatio = travelDuration / leg.estimatedTravelTime;
            const lat = origin.locationCoords.lat + (destination.locationCoords.lat - origin.locationCoords.lat) * travelRatio;
            const lng = origin.locationCoords.lng + (destination.locationCoords.lng - origin.locationCoords.lng) * travelRatio;
            return {
              status: "TRAVELING",
              location: {
                lat,
                lng
              },
              details: `Traveling to ${destination.address}. Arrives at ${minutesTo12HourFormat(nextStopTime)}.`
            };
          }
        }
      }
      return {
        status: "AT_HOME",
        location: person.start,
        details: "Route complete for the day."
      }; // Fallback
    };

    function findAvailableInspectors() {
      const addressInput = document.getElementById('new-inspection-address');
      const newInspectionLat = parseFloat(addressInput.dataset.lat);
      const newInspectionLng = parseFloat(addressInput.dataset.lng);
      if (isNaN(newInspectionLat) || isNaN(newInspectionLng)) {
        alert("Please enter an address and click 'Find on Map' first.");
        return;
      }
      const newInspectionCoords = {
        lat: newInspectionLat,
        lng: newInspectionLng
      };
      const proposedStartTime = timeStringToMinutes(document.getElementById('inspection-time').value);
      const proposedDuration = parseInt(document.getElementById('inspection-duration').value, 10);
      const results = [];
      const bounds = L.latLngBounds([newInspectionCoords]);
      schedulerLayerGroup.eachLayer(layer => {
        if (!layer.options.isNewInspection) {
          schedulerLayerGroup.removeLayer(layer);
        }
      });
      peopleRouteData.forEach(person => {
        const state = getInspectorStateAtTime(person, proposedStartTime);
        let feasibility = {
          canDoIt: 'No',
          travelToNew: Infinity,
          initialDetails: state.details,
          scenarioDetails: null
        };
        if (state.status !== 'ON_INSPECTION') {
          const travelToNew = (calculateDistance(state.location.lat, state.location.lng, newInspectionCoords.lat, newInspectionCoords.lng) / AVERAGE_SPEED_MPH) * 60;
          const arrivalAtNew = proposedStartTime + travelToNew;
          const newInspectionEndTime = arrivalAtNew + proposedDuration;
          const nextAppointment = person.stops.find(s => timeStringToMinutes(s.timeEST) >= newInspectionEndTime);
          let travelToNext = 0;
          let buffer = Infinity;
          if (nextAppointment) {
            travelToNext = (calculateDistance(newInspectionCoords.lat, newInspectionCoords.lng, nextAppointment.locationCoords.lat, nextAppointment.locationCoords.lng) / AVERAGE_SPEED_MPH) * 60;
            buffer = timeStringToMinutes(nextAppointment.timeEST) - (newInspectionEndTime + travelToNext);
          } else {
            // If no next appointment, buffer is effectively infinite
            buffer = Infinity;
          }
          if (buffer >= 0) {
            if (person.stops.length === 0) {
              feasibility.canDoIt = 'Yes (Office - Avoid)';
            } else {
              feasibility.canDoIt = buffer < MIN_TRAVEL_BUFFER_MINUTES ? 'Tight Fit' : 'Yes';
            }
            feasibility.scenarioDetails = {
              newEndTime: minutesTo12HourFormat(newInspectionEndTime),
              travelToNext: formatDuration(travelToNext),
              nextAppointmentTime: nextAppointment ? formatTime12Hour(nextAppointment.timeEST) : 'N/A',
              nextAppointmentAddress: nextAppointment ? nextAppointment.address : 'None',
              buffer: formatDuration(buffer)
            };
          }
          feasibility.travelToNew = travelToNew;
        }
        results.push({
          ...person,
          ...feasibility
        });
        const markerColor = feasibility.canDoIt.startsWith('Yes') ? (feasibility.canDoIt.includes('Office') ? 'var(--available-office-color)' : 'var(--available-color)') : (feasibility.canDoIt === 'Tight Fit' ? 'var(--tight-fit-color)' : 'var(--unavailable-color)');
        const icon = L.divIcon({
          html: `<div style="background-color:${markerColor}; width:12px; height:12px; border-radius:50%; border: 2px solid white; box-shadow: 0 0 5px black;"></div>`,
          className: '',
          iconSize: [16, 16],
          iconAnchor: [8, 8]
        });
        L.marker(state.location, {
            icon,
            zIndexOffset: 900
          })
          .addTo(schedulerLayerGroup)
          .bindTooltip(`${person.name}<br><b>${feasibility.canDoIt}</b>`);
        bounds.extend(state.location);
      });
      populateSchedulerTable(results);
      map.flyToBounds(bounds, {
        padding: [50, 50]
      });
    }

    function populateSchedulerTable(results) {
      const tableBody = document.querySelector('#scheduler-results-table tbody');
      tableBody.innerHTML = '';
      results.sort((a, b) => {
        const order = {
          'Yes': 1,
          'Yes (Office - Avoid)': 2,
          'Tight Fit': 3,
          'No': 4
        };
        if (order[a.canDoIt] !== order[b.canDoIt]) {
          return order[a.canDoIt] - order[b.canDoIt];
        }
        return a.travelToNew - b.travelToNew;
      });
      if (results.length === 0) {
        tableBody.innerHTML = '<tr><td colspan="5" style="text-align:center;">No inspectors found.</td></tr>';
        return;
      }
      results.forEach(res => {
        const badgeClass = res.canDoIt.startsWith('Yes') ? (res.canDoIt.includes('Office') ? 'office-avoid' : 'available') : (res.canDoIt === 'Tight Fit' ? 'tight-fit' : 'unavailable');
        let detailsHTML = `<div>${res.initialDetails}</div>`;
        if (res.scenarioDetails) {
          detailsHTML += `
                        <div class="if-assigned-details">
                            <div class="title">If Assigned This Job:</div>
                            <ul>
                                <li>New job would end at: <b>${res.scenarioDetails.newEndTime}</b></li>
                                ${res.scenarioDetails.nextAppointmentAddress !== 'None' ? `
                                <li>Travel to next stop: <b>${res.scenarioDetails.travelToNext}</b></li>
                                <li>Next is at <b>${res.scenarioDetails.nextAppointmentTime}</b> (${res.scenarioDetails.nextAppointmentAddress})</li>
                                <li>Arrives with <b>${res.scenarioDetails.buffer}</b> of buffer time.</li>
                                ` : '<li>This would be the last stop of the day.</li>'}
                            </ul>
                        </div>
                    `;
        }
        const row = `
                    <tr>
                        <td><span class="status-badge ${badgeClass}">${res.canDoIt}</span></td>
                        <td>${res.name}</td>
                        <td>${res.stops.length}</td>
                        <td>${res.travelToNew !== Infinity ? formatDuration(res.travelToNew) : 'N/A'}</td>
                        <td>${detailsHTML}</td>
                    </tr>
                `;
        tableBody.innerHTML += row;
      });
    }

    // --- WRAPPED APPLICATION INITIALIZATION LOGIC (MODIFIED) ---
    /**
     * This function contains the main application logic. 
     * It is called only after the rawData is received from the parent window.
     */
    function runApplication(data) {
      // 1. Assign the received data to the global variable
      rawData = data;

      // 2. Run the original initialization code
      const {
        cleanSchedules,
        dataIssues
      } = filterAndPrepareSchedules(rawData.schedules);
      const appData = {
        ...rawData,
        schedules: cleanSchedules,
        dataIssues,
        conflicts: rawData.conflicts || []
      };
      peopleRouteData = processData(appData);

      if (initializeMap()) {
        const dateDisplay = document.getElementById('route-date-display');
        dateDisplay.textContent = formatDateForHeader(new Date());
        renderRoutesAndLegend(appData);
        initializeSpecialButtonsAndModals(appData);
        const legend = document.getElementById('legend');
        const infoPanel = document.getElementById('info-panel');
        const menuBtn = document.getElementById('mobile-menu-btn');
        const mapContainer = document.getElementById('map-container');

        document.body.addEventListener('click', function(e) {
          if (e.target.classList.contains('copy-tooltip-btn')) {
            const textToCopy = e.target.getAttribute('data-copy-text');
            navigator.clipboard.writeText(textToCopy).then(() => {
              e.target.textContent = 'Copied!';
              setTimeout(() => {
                e.target.textContent = '📋';
              }, 1500);
            }).catch(err => console.error('Failed to copy text: ', err));
          }
        });

        const updateMenuButtonState = () => {
          const isOpen = legend.classList.contains('is-open') || infoPanel.classList.contains('is-visible');
          menuBtn.classList.toggle('is-active', isOpen);
        };

        document.getElementById('exit-focus-btn-map').addEventListener('click', () => {
          exitFocusMode();
          hideInspectorInfo();
        });
        document.addEventListener('keydown', handleKeyDown);
        map.on('click', exitTabFocus);

        if (menuBtn && legend) {
          menuBtn.addEventListener('click', e => {
            e.stopPropagation();
            exitTabFocus();
            if (lastOpenPanel === 'info' && focusedPersonId) {
              infoPanel.classList.toggle('is-visible');
              document.body.classList.toggle('info-panel-active');
            } else {
              legend.classList.toggle('is-open');
            }
            updateMenuButtonState();
          });
          mapContainer.addEventListener('click', () => {
            if (window.innerWidth <= 900) {
              if (legend.classList.contains('is-open')) {
                legend.classList.remove('is-open');
              }
              if (infoPanel.classList.contains('is-visible')) {
                infoPanel.classList.remove('is-visible');
                document.body.classList.remove('info-panel-active');
              }
              updateMenuButtonState();
            }
          });
        }
        animateAllPolylines();
        setTimeout(fitAllVisibleRoutes, 500);
      }
    }

    // --- PARENT COMMUNICATION & APP TRIGGER (MODIFIED) ---
    window.addEventListener('DOMContentLoaded', () => {
      console.log('Iframe loaded, notifying parent it is ready to receive data.');
      // Notify parent that iframe is ready
      window.parent.postMessage({
        type: 'iframe-ready'
      }, '*');

      // Listen for messages from parent
      window.addEventListener('message', (event) => {
        console.log('Iframe received a message from parent:', event.data);

        // Check if the message contains the rawData to initialize the map
        if (event.data && event.data.rawData) {
          console.log(`Received rawData, initializing application...`);
          
          // Run the main application logic with the received data
          runApplication(event.data.rawData);

          // Send a response back to parent confirming initialization
          window.parent.postMessage({
            type: 'iframe-response',
            message: 'Iframe successfully received the data and initialized!',
            data: { received: true }
          }, '*');
        }
      });
    });

    /**
     * Sends a sample data object back to the parent page.
     */
    function sendDataToParent() {
      console.log("Sending data back to parent page...");

      const dataToSend = {
        type: 'mapDataReturn',
        payload: {
          summary: "User finished interacting with the map.",
          visibleRoutes: Object.values(personLayersData).filter(p => p.isVisible).length,
          totalMiles: document.querySelector('#legend-summary td:nth-child(3)').textContent,
          timestamp: new Date().toISOString()
        }
      };

      window.parent.postMessage(dataToSend, '*');
      alert('Data has been sent back to the main page!');
    }
  </script>
  
</body>

</html>
